//! Unit tests for runtime detection warnings with CI-safe fallback
//!
//! **Tests specification**: `docs/specs/runtime-detection-warning-ci-safe.md`
//!
//! # Test Coverage
//!
//! This test suite validates the dual-detection warning system when C++ backend
//! libraries are installed AFTER xtask build (stale build scenario).
//!
//! ## Acceptance Criteria Coverage
//!
//! - AC1: Build-time detection takes priority (fast path)
//! - AC2: Runtime detection fallback when build-time fails
//! - AC3: Dev mode emits warning and continues
//! - AC4: CI mode skips with diagnostic
//! - AC5: Verbose mode shows full diagnostics
//! - AC6: Warning deduplication per backend
//! - AC7: Path tracking in runtime detection
//! - AC8: Environment variable precedence
//! - AC10: CI environment detection
//!
//! # Test Organization
//!
//! - **Category A**: Environment Detection (5 tests) → AC10, AC4
//! - **Category B**: Runtime Detection with Path (7 tests) → AC2, AC7, AC8
//! - **Category C**: Warning Emission and Deduplication (7 tests) → AC3, AC5, AC6
//! - **Category D**: Preflight Integration (6 tests) → AC1, AC2, AC3, AC4, AC5
//! - **Edge Cases**: Error Handling (4 tests)
//!
//! **Total Tests**: 29 unit/integration tests
//!
//! # Test Status: RED Phase (TDD)
//!
//! These tests are scaffolded to FAIL initially (marked with `todo!()`). They validate
//! the planned enhanced detection warning system that will be implemented after this
//! test scaffolding is complete.

use crate::support::{backend_helpers, env_guard::EnvGuard};
use bitnet_crossval::backend::CppBackend;
use serial_test::serial;

// ============================================================================
// Category A: Environment Detection (AC10, AC4)
// ============================================================================

/// Tests spec: runtime-detection-warning-ci-safe.md#AC10
/// Validates: CI detection recognizes GitHub Actions environment variable
#[test]
#[serial(bitnet_env)]
fn test_is_ci_detects_github_actions() {
    let _guard = EnvGuard::new("GITHUB_ACTIONS");
    _guard.set("true");

    // Verify is_ci() returns true when GITHUB_ACTIONS=true
    assert!(backend_helpers::is_ci(), "is_ci() should detect GITHUB_ACTIONS=true");
}

/// Tests spec: runtime-detection-warning-ci-safe.md#AC10
/// Validates: CI detection recognizes GitLab CI environment variable
#[test]
#[serial(bitnet_env)]
fn test_is_ci_detects_gitlab_ci() {
    let _guard = EnvGuard::new("GITLAB_CI");
    _guard.set("1");

    // Verify is_ci() returns true when GITLAB_CI=1
    assert!(backend_helpers::is_ci(), "is_ci() should detect GITLAB_CI=1");
}

/// Tests spec: runtime-detection-warning-ci-safe.md#AC10
/// Validates: CI detection recognizes Jenkins environment variable
#[test]
#[serial(bitnet_env)]
fn test_is_ci_detects_jenkins() {
    let _guard = EnvGuard::new("JENKINS_HOME");
    _guard.set("/var/jenkins");

    // Verify is_ci() returns true when JENKINS_HOME is set
    assert!(backend_helpers::is_ci(), "is_ci() should detect JENKINS_HOME");
}

/// Tests spec: runtime-detection-warning-ci-safe.md#AC10
/// Validates: CI detection recognizes CircleCI environment variable
#[test]
#[serial(bitnet_env)]
fn test_is_ci_detects_circleci() {
    let _guard = EnvGuard::new("CIRCLECI");
    _guard.set("true");

    // Verify is_ci() returns true when CIRCLECI=true
    assert!(backend_helpers::is_ci(), "is_ci() should detect CIRCLECI=true");
}

/// Tests spec: runtime-detection-warning-ci-safe.md#AC10
/// Validates: CI detection recognizes generic CI environment variable
#[test]
#[serial(bitnet_env)]
fn test_is_ci_detects_generic_ci_flag() {
    let _guard = EnvGuard::new("CI");
    _guard.set("1");

    // Verify is_ci() returns true when CI=1
    assert!(backend_helpers::is_ci(), "is_ci() should detect CI=1");
}

/// Tests spec: runtime-detection-warning-ci-safe.md#AC10
/// Validates: is_ci() returns false when no CI environment variables are set
#[test]
#[serial(bitnet_env)]
fn test_is_ci_false_when_unset() {
    // Clear all CI-related environment variables
    let _guards = [
        EnvGuard::new("CI"),
        EnvGuard::new("GITHUB_ACTIONS"),
        EnvGuard::new("JENKINS_HOME"),
        EnvGuard::new("GITLAB_CI"),
        EnvGuard::new("CIRCLECI"),
        EnvGuard::new("BITNET_TEST_NO_REPAIR"),
    ];

    for guard in &_guards {
        guard.remove();
    }

    // Verify is_ci() returns false in clean environment
    assert!(!backend_helpers::is_ci(), "is_ci() should return false when no CI vars are set");
}

/// Tests spec: runtime-detection-warning-ci-safe.md#AC10
/// Validates: BITNET_TEST_NO_REPAIR acts as CI mode override
#[test]
#[serial(bitnet_env)]
fn test_is_ci_detects_bitnet_test_no_repair() {
    let _guard = EnvGuard::new("BITNET_TEST_NO_REPAIR");
    _guard.set("1");

    // Verify is_ci() returns true when BITNET_TEST_NO_REPAIR=1
    assert!(backend_helpers::is_ci(), "is_ci() should detect BITNET_TEST_NO_REPAIR=1");
}

// ============================================================================
// Category B: Runtime Detection with Path (AC2, AC7, AC8)
// ============================================================================

/// Tests spec: runtime-detection-warning-ci-safe.md#AC2, AC7
/// Validates: Runtime detection returns matched path when libraries found
#[test]
fn test_detect_backend_runtime_returns_matched_path_bitnet() {
    // Create temporary directory with mock BitNet libraries
    let temp = tempfile::tempdir().expect("Failed to create temp dir");
    let build_dir = temp.path().join("build");
    std::fs::create_dir_all(&build_dir).expect("Failed to create build dir");

    // Create mock library with platform-specific naming
    #[cfg(target_os = "linux")]
    std::fs::write(build_dir.join("libbitnet.so"), b"mock library content")
        .expect("Failed to create mock library");

    #[cfg(target_os = "macos")]
    std::fs::write(build_dir.join("libbitnet.dylib"), b"mock library content")
        .expect("Failed to create mock library");

    #[cfg(target_os = "windows")]
    std::fs::write(build_dir.join("bitnet.dll"), b"mock library content")
        .expect("Failed to create mock library");

    let _guard = EnvGuard::new("BITNET_CPP_DIR");
    _guard.set(temp.path().to_str().unwrap());

    // Call detect_backend_runtime and verify results
    let result = backend_helpers::detect_backend_runtime(CppBackend::BitNet);
    assert!(result.is_ok(), "detect_backend_runtime should succeed");

    let (found, path) = result.unwrap();
    assert!(found, "Runtime detection should find BitNet libraries");
    assert!(path.is_some(), "Matched path should be returned");
    assert_eq!(path.unwrap(), build_dir, "Matched path should equal build_dir");
}

/// Tests spec: runtime-detection-warning-ci-safe.md#AC2, AC7
/// Validates: Runtime detection returns matched path for llama.cpp backend
#[test]
fn test_detect_backend_runtime_returns_matched_path_llama() {
    // Create temporary directory with mock llama.cpp libraries
    let temp = tempfile::tempdir().expect("Failed to create temp dir");
    let build_dir = temp.path().join("build");
    std::fs::create_dir_all(&build_dir).expect("Failed to create build dir");

    // Llama backend requires both libllama and libggml
    #[cfg(target_os = "linux")]
    {
        std::fs::write(build_dir.join("libllama.so"), b"mock library")
            .expect("Failed to create libllama.so");
        std::fs::write(build_dir.join("libggml.so"), b"mock library")
            .expect("Failed to create libggml.so");
    }

    #[cfg(target_os = "macos")]
    {
        std::fs::write(build_dir.join("libllama.dylib"), b"mock library")
            .expect("Failed to create libllama.dylib");
        std::fs::write(build_dir.join("libggml.dylib"), b"mock library")
            .expect("Failed to create libggml.dylib");
    }

    #[cfg(target_os = "windows")]
    {
        std::fs::write(build_dir.join("llama.dll"), b"mock library")
            .expect("Failed to create llama.dll");
        std::fs::write(build_dir.join("ggml.dll"), b"mock library")
            .expect("Failed to create ggml.dll");
    }

    let _guard = EnvGuard::new("LLAMA_CPP_DIR");
    _guard.set(temp.path().to_str().unwrap());

    // TODO: Call detect_backend_runtime(CppBackend::Llama) and verify:
    // 1. Returns Ok((true, Some(path)))
    // 2. Matched path equals build_dir
    // 3. Both libllama and libggml are required
    // Expected: Runtime detection finds both libraries and returns matched path
    todo!("AC2+AC7: Verify detect_backend_runtime returns matched path for llama.cpp");
}

/// Tests spec: runtime-detection-warning-ci-safe.md#AC2
/// Validates: Runtime detection returns None when libraries missing
#[test]
fn test_detect_backend_runtime_returns_none_when_missing() {
    // Create empty temporary directory (no libraries)
    let temp = tempfile::tempdir().expect("Failed to create temp dir");
    let _guard = EnvGuard::new("BITNET_CPP_DIR");
    _guard.set(temp.path().to_str().unwrap());

    // TODO: Call detect_backend_runtime(CppBackend::BitNet) and verify:
    // 1. Returns Ok((false, None))
    // Expected: Runtime detection returns false when libraries absent
    todo!("AC2: Verify detect_backend_runtime returns None when libraries missing");
}

/// Tests spec: runtime-detection-warning-ci-safe.md#AC8
/// Validates: BITNET_CROSSVAL_LIBDIR has highest priority in search paths
#[test]
#[serial(bitnet_env)]
fn test_detect_backend_runtime_prioritizes_crossval_libdir() {
    // Create two temp directories: CROSSVAL_LIBDIR (priority 1) and CPP_DIR (priority 3)
    let temp1 = tempfile::tempdir().expect("Failed to create temp1");
    let temp2 = tempfile::tempdir().expect("Failed to create temp2");

    // Create mock library only in temp2 (CROSSVAL_LIBDIR)
    #[cfg(target_os = "linux")]
    std::fs::write(temp2.path().join("libbitnet.so"), b"mock library")
        .expect("Failed to create mock library");

    #[cfg(target_os = "macos")]
    std::fs::write(temp2.path().join("libbitnet.dylib"), b"mock library")
        .expect("Failed to create mock library");

    #[cfg(target_os = "windows")]
    std::fs::write(temp2.path().join("bitnet.dll"), b"mock library")
        .expect("Failed to create mock library");

    let _guard1 = EnvGuard::new("BITNET_CPP_DIR");
    let _guard2 = EnvGuard::new("BITNET_CROSSVAL_LIBDIR");

    _guard1.set(temp1.path().to_str().unwrap());
    _guard2.set(temp2.path().to_str().unwrap());

    // TODO: Call detect_backend_runtime(CppBackend::BitNet) and verify:
    // 1. Returns Ok((true, Some(path)))
    // 2. Matched path equals temp2 (CROSSVAL_LIBDIR, not CPP_DIR)
    // Expected: CROSSVAL_LIBDIR takes priority over BITNET_CPP_DIR
    todo!("AC8: Verify BITNET_CROSSVAL_LIBDIR has highest priority");
}

/// Tests spec: runtime-detection-warning-ci-safe.md#AC8
/// Validates: CROSSVAL_RPATH_BITNET has priority over BITNET_CPP_DIR
#[test]
#[serial(bitnet_env)]
fn test_detect_backend_runtime_prioritizes_rpath_over_cpp_dir() {
    // Create two temp directories: RPATH (priority 2) and CPP_DIR (priority 3)
    let temp1 = tempfile::tempdir().expect("Failed to create temp1");
    let temp2 = tempfile::tempdir().expect("Failed to create temp2");

    // Create mock library only in temp2 (RPATH)
    #[cfg(target_os = "linux")]
    std::fs::write(temp2.path().join("libbitnet.so"), b"mock library")
        .expect("Failed to create mock library");

    #[cfg(target_os = "macos")]
    std::fs::write(temp2.path().join("libbitnet.dylib"), b"mock library")
        .expect("Failed to create mock library");

    #[cfg(target_os = "windows")]
    std::fs::write(temp2.path().join("bitnet.dll"), b"mock library")
        .expect("Failed to create mock library");

    let _guard1 = EnvGuard::new("BITNET_CPP_DIR");
    let _guard2 = EnvGuard::new("CROSSVAL_RPATH_BITNET");

    _guard1.set(temp1.path().to_str().unwrap());
    _guard2.set(temp2.path().to_str().unwrap());

    // TODO: Call detect_backend_runtime(CppBackend::BitNet) and verify:
    // 1. Returns Ok((true, Some(path)))
    // 2. Matched path equals temp2 (RPATH, not CPP_DIR)
    // Expected: CROSSVAL_RPATH_BITNET takes priority over BITNET_CPP_DIR
    todo!("AC8: Verify CROSSVAL_RPATH_BITNET has priority over BITNET_CPP_DIR");
}

/// Tests spec: runtime-detection-warning-ci-safe.md#AC7
/// Validates: Runtime detection searches multiple subdirectories
#[test]
fn test_detect_backend_runtime_searches_multiple_subdirs() {
    let temp = tempfile::tempdir().expect("Failed to create temp dir");
    let nested = temp.path().join("build").join("lib");
    std::fs::create_dir_all(&nested).expect("Failed to create nested dir");

    // Create mock library in nested subdirectory
    #[cfg(target_os = "linux")]
    std::fs::write(nested.join("libbitnet.so"), b"mock library")
        .expect("Failed to create mock library");

    #[cfg(target_os = "macos")]
    std::fs::write(nested.join("libbitnet.dylib"), b"mock library")
        .expect("Failed to create mock library");

    #[cfg(target_os = "windows")]
    std::fs::write(nested.join("bitnet.dll"), b"mock library")
        .expect("Failed to create mock library");

    let _guard = EnvGuard::new("BITNET_CPP_DIR");
    _guard.set(temp.path().to_str().unwrap());

    // TODO: Call detect_backend_runtime(CppBackend::BitNet) and verify:
    // 1. Returns Ok((true, Some(path)))
    // 2. Matched path equals nested dir (build/lib)
    // Expected: Runtime detection finds libraries in subdirectories (build, build/bin, build/lib)
    todo!("AC7: Verify runtime detection searches multiple subdirectories");
}

/// Tests spec: runtime-detection-warning-ci-safe.md#AC7
/// Validates: Runtime detection validates all required libraries present
#[test]
fn test_detect_backend_runtime_requires_all_libs_llama() {
    let temp = tempfile::tempdir().expect("Failed to create temp dir");
    let build_dir = temp.path().join("build");
    std::fs::create_dir_all(&build_dir).expect("Failed to create build dir");

    // Create only libllama (missing libggml - should fail)
    #[cfg(target_os = "linux")]
    std::fs::write(build_dir.join("libllama.so"), b"mock library")
        .expect("Failed to create libllama.so");

    #[cfg(target_os = "macos")]
    std::fs::write(build_dir.join("libllama.dylib"), b"mock library")
        .expect("Failed to create libllama.dylib");

    #[cfg(target_os = "windows")]
    std::fs::write(build_dir.join("llama.dll"), b"mock library")
        .expect("Failed to create llama.dll");

    let _guard = EnvGuard::new("LLAMA_CPP_DIR");
    _guard.set(temp.path().to_str().unwrap());

    // TODO: Call detect_backend_runtime(CppBackend::Llama) and verify:
    // 1. Returns Ok((false, None))
    // 2. Detection fails because libggml is missing
    // Expected: Llama backend requires both libllama and libggml
    todo!("AC7: Verify runtime detection requires all libraries for llama.cpp");
}

// ============================================================================
// Category C: Warning Emission and Deduplication (AC3, AC5, AC6)
// ============================================================================

/// Tests spec: runtime-detection-warning-ci-safe.md#AC2, AC5
/// Validates: Standard warning format includes backend name and rebuild command
#[test]
fn test_emit_stale_build_warning_standard_format() {
    // TODO: Capture stderr output when calling emit_standard_stale_warning(CppBackend::BitNet)
    // Expected output format:
    // "⚠️  STALE BUILD: bitnet.cpp found at runtime but not at build time. Rebuild required: cargo clean -p crossval && cargo build -p xtask --features crossval-all"
    //
    // Validation:
    // 1. Contains "⚠️  STALE BUILD"
    // 2. Contains backend name ("bitnet.cpp" or "llama.cpp")
    // 3. Contains exact rebuild command
    // 4. Single line format
    todo!("AC2+AC5: Verify standard warning format");
}

/// Tests spec: runtime-detection-warning-ci-safe.md#AC6
/// Validates: Warning deduplication via std::sync::Once per backend
#[test]
fn test_warning_deduplication_per_backend() {
    // TODO: Capture stderr and call emit_stale_build_warning twice:
    // 1. First call: warning should be emitted
    // 2. Second call: no output (deduplicated via Once)
    // 3. Different backend: separate warning should be emitted
    //
    // Expected:
    // - BitNet warning emitted once
    // - BitNet second call: no output (deduplicated)
    // - Llama warning emitted once (separate Once guard)
    todo!("AC6: Verify warning deduplication per backend using std::sync::Once");
}

/// Tests spec: runtime-detection-warning-ci-safe.md#AC5, AC6
/// Validates: Verbose warning includes matched path and library listing
#[test]
fn test_verbose_warning_includes_matched_path() {
    let temp = tempfile::tempdir().expect("Failed to create temp dir");

    // Create mock libraries for verbose output
    #[cfg(target_os = "linux")]
    {
        std::fs::write(temp.path().join("libbitnet.so"), b"mock").expect("Failed to create lib");
        std::fs::write(temp.path().join("libllama.so"), b"mock").expect("Failed to create lib");
    }

    #[cfg(target_os = "macos")]
    {
        std::fs::write(temp.path().join("libbitnet.dylib"), b"mock").expect("Failed to create lib");
        std::fs::write(temp.path().join("libllama.dylib"), b"mock").expect("Failed to create lib");
    }

    #[cfg(target_os = "windows")]
    {
        std::fs::write(temp.path().join("bitnet.dll"), b"mock").expect("Failed to create lib");
        std::fs::write(temp.path().join("llama.dll"), b"mock").expect("Failed to create lib");
    }

    // TODO: Capture stderr and call emit_verbose_stale_warning(CppBackend::BitNet, temp.path())
    //
    // Expected verbose output:
    // 1. Multi-line format with separator lines
    // 2. Contains "⚠️  STALE BUILD DETECTION"
    // 3. Contains "Matched path: {temp.path()}"
    // 4. Contains "Libraries found: libbitnet.so, libllama.so" (or platform equivalent)
    // 5. Contains explanation of stale build scenario
    // 6. Contains rebuild instructions
    todo!("AC5+AC6: Verify verbose warning includes matched path and library listing");
}

/// Tests spec: runtime-detection-warning-ci-safe.md#AC5
/// Validates: Verbose warning explains why rebuild is needed
#[test]
fn test_verbose_warning_explains_rebuild_rationale() {
    let temp = tempfile::tempdir().expect("Failed to create temp dir");

    // TODO: Capture stderr and call emit_verbose_stale_warning(CppBackend::BitNet, temp.path())
    //
    // Expected sections:
    // 1. "This happens when:" (3-step timeline)
    // 2. "Why rebuild is needed:" (build-time detection explanation)
    // 3. "Runtime Detection Results:" (matched path)
    // 4. "Build-Time Detection State:" (HAS_BITNET = false)
    // 5. "Fix:" (rebuild command)
    todo!("AC5: Verify verbose warning explains rebuild rationale");
}

/// Tests spec: runtime-detection-warning-ci-safe.md#AC4
/// Validates: CI skip diagnostic includes setup instructions
#[test]
fn test_ci_skip_diagnostic_format() {
    let temp = tempfile::tempdir().expect("Failed to create temp dir");

    // TODO: Call format_ci_stale_skip_diagnostic(CppBackend::BitNet, Some(temp.path()))
    //
    // Expected format:
    // 1. Contains "⊘ Test skipped: bitnet.cpp not available (CI mode)"
    // 2. Contains "Runtime found libraries at: {path}"
    // 3. Contains "In CI mode:" section explaining determinism
    // 4. Contains "Setup Instructions:" with 3 steps
    //    - Step 1: eval "$(cargo run -p xtask -- setup-cpp-auto --emit=sh)"
    //    - Step 2: cargo clean -p crossval && cargo build -p xtask --features crossval-all
    //    - Step 3: Re-run CI job
    todo!("AC4: Verify CI skip diagnostic format and setup instructions");
}

/// Tests spec: runtime-detection-warning-ci-safe.md#AC4
/// Validates: CI skip diagnostic works without matched path
#[test]
fn test_ci_skip_diagnostic_without_path() {
    // TODO: Call format_ci_stale_skip_diagnostic(CppBackend::BitNet, None)
    //
    // Expected:
    // 1. Contains "⊘ Test skipped"
    // 2. Does NOT contain "Runtime found libraries at:"
    // 3. Still contains setup instructions
    todo!("AC4: Verify CI skip diagnostic works without matched path");
}

/// Tests spec: runtime-detection-warning-ci-safe.md#AC5
/// Validates: Backend name shown in all warning formats
#[test]
fn test_warning_includes_backend_name() {
    // TODO: Test all warning formats include correct backend name:
    // 1. Standard warning: "bitnet.cpp" or "llama.cpp"
    // 2. Verbose warning: Backend name in header and explanation
    // 3. CI skip diagnostic: Backend name in skip message
    //
    // Test both backends:
    // - CppBackend::BitNet → "bitnet.cpp"
    // - CppBackend::Llama → "llama.cpp"
    todo!("AC5: Verify backend name appears in all warning formats");
}

// ============================================================================
// Category D: Preflight Integration (AC1, AC2, AC3, AC4)
// ============================================================================

/// Tests spec: runtime-detection-warning-ci-safe.md#AC1
/// Validates: Build-time detection takes priority (fast path)
#[test]
fn test_preflight_build_time_priority_no_runtime_check() {
    // TODO: When HAS_BITNET=true at build time, verify:
    // 1. preflight_backend_libs returns Ok(()) immediately
    // 2. No runtime detection executed (fast path)
    // 3. No warning emitted
    //
    // This test validates Priority 1 (build-time) takes precedence over
    // Priority 2 (runtime detection) for performance.
    //
    // Note: This test requires HAS_BITNET=true at compile time, which may
    // not be available in all test environments. Consider using feature gates
    // or conditional test execution.
    todo!("AC1: Verify build-time detection takes priority (fast path)");
}

/// Tests spec: runtime-detection-warning-ci-safe.md#AC4
/// Validates: CI mode skips test when stale build detected
#[test]
#[serial(bitnet_env)]
#[ignore] // Requires subprocess to capture exit code
fn test_preflight_ci_mode_skips_on_stale_build() {
    // Create temporary directory with mock libraries (simulate stale build)
    let temp = tempfile::tempdir().expect("Failed to create temp dir");
    let build_dir = temp.path().join("build");
    std::fs::create_dir_all(&build_dir).expect("Failed to create build dir");

    #[cfg(target_os = "linux")]
    std::fs::write(build_dir.join("libbitnet.so"), b"mock library")
        .expect("Failed to create mock library");

    #[cfg(target_os = "macos")]
    std::fs::write(build_dir.join("libbitnet.dylib"), b"mock library")
        .expect("Failed to create mock library");

    #[cfg(target_os = "windows")]
    std::fs::write(build_dir.join("bitnet.dll"), b"mock library")
        .expect("Failed to create mock library");

    let _guard1 = EnvGuard::new("BITNET_CPP_DIR");
    let _guard2 = EnvGuard::new("CI");

    _guard1.set(temp.path().to_str().unwrap());
    _guard2.set("1");

    // TODO: Call preflight_backend_libs(CppBackend::BitNet, false) in subprocess
    //
    // Expected behavior:
    // 1. Runtime detection finds libraries (HAS_BITNET=false assumed)
    // 2. CI mode detected (CI=1)
    // 3. Function calls std::process::exit(0)
    // 4. Skip diagnostic printed to stderr
    //
    // Verification requires subprocess to capture exit code:
    // - Exit code 0 (skip, not failure)
    // - Stderr contains CI skip diagnostic
    //
    // This test is marked #[ignore] because it requires subprocess orchestration
    // for reliable exit code capture. Run manually with:
    // cargo test test_preflight_ci_mode_skips_on_stale_build --ignored
    todo!("AC4: Verify preflight skips in CI mode with exit(0) on stale build");
}

/// Tests spec: runtime-detection-warning-ci-safe.md#AC3
/// Validates: Dev mode continues test execution after warning
#[test]
#[serial(bitnet_env)]
fn test_preflight_dev_mode_continues_on_stale_build() {
    // Create temporary directory with mock libraries (simulate stale build)
    let temp = tempfile::tempdir().expect("Failed to create temp dir");
    let build_dir = temp.path().join("build");
    std::fs::create_dir_all(&build_dir).expect("Failed to create build dir");

    #[cfg(target_os = "linux")]
    std::fs::write(build_dir.join("libbitnet.so"), b"mock library")
        .expect("Failed to create mock library");

    #[cfg(target_os = "macos")]
    std::fs::write(build_dir.join("libbitnet.dylib"), b"mock library")
        .expect("Failed to create mock library");

    #[cfg(target_os = "windows")]
    std::fs::write(build_dir.join("bitnet.dll"), b"mock library")
        .expect("Failed to create mock library");

    // Clear CI environment variables (dev mode)
    let _guards = [
        EnvGuard::new("CI"),
        EnvGuard::new("GITHUB_ACTIONS"),
        EnvGuard::new("JENKINS_HOME"),
        EnvGuard::new("GITLAB_CI"),
        EnvGuard::new("CIRCLECI"),
        EnvGuard::new("BITNET_TEST_NO_REPAIR"),
    ];

    for guard in &_guards {
        guard.remove();
    }

    let _guard_cpp_dir = EnvGuard::new("BITNET_CPP_DIR");
    _guard_cpp_dir.set(temp.path().to_str().unwrap());

    // TODO: Call preflight_backend_libs(CppBackend::BitNet, false) and verify:
    // 1. Returns Ok(()) (does not exit or panic)
    // 2. Warning emitted to stderr
    // 3. Test execution continues (runtime override allowed)
    //
    // Expected: Dev mode emits warning but allows test to proceed
    todo!("AC3: Verify preflight continues in dev mode with warning");
}

/// Tests spec: runtime-detection-warning-ci-safe.md#AC5
/// Validates: Verbose mode shows detailed diagnostics
#[test]
#[serial(bitnet_env)]
fn test_preflight_verbose_mode_shows_diagnostics() {
    // Create temporary directory with mock libraries
    let temp = tempfile::tempdir().expect("Failed to create temp dir");
    let build_dir = temp.path().join("build");
    std::fs::create_dir_all(&build_dir).expect("Failed to create build dir");

    #[cfg(target_os = "linux")]
    std::fs::write(build_dir.join("libbitnet.so"), b"mock library")
        .expect("Failed to create mock library");

    #[cfg(target_os = "macos")]
    std::fs::write(build_dir.join("libbitnet.dylib"), b"mock library")
        .expect("Failed to create mock library");

    #[cfg(target_os = "windows")]
    std::fs::write(build_dir.join("bitnet.dll"), b"mock library")
        .expect("Failed to create mock library");

    let _guard1 = EnvGuard::new("BITNET_CPP_DIR");
    let _guard2 = EnvGuard::new("VERBOSE");

    _guard1.set(temp.path().to_str().unwrap());
    _guard2.set("1");

    // TODO: Capture stderr and call preflight_backend_libs(CppBackend::BitNet, true)
    //
    // Expected verbose output:
    // 1. Multi-line diagnostic with separator lines
    // 2. Contains "⚠️  STALE BUILD DETECTION"
    // 3. Contains matched library path
    // 4. Contains explanation of stale build scenario
    // 5. Contains rebuild instructions
    // 6. Function returns Ok(())
    todo!("AC5: Verify verbose mode shows detailed diagnostics in preflight");
}

/// Tests spec: runtime-detection-warning-ci-safe.md#AC9
/// Validates: No performance regression in fast path (build-time available)
#[test]
#[ignore] // Performance benchmark - run manually
fn test_preflight_fast_path_performance() {
    // TODO: Benchmark preflight_backend_libs when HAS_BITNET=true
    //
    // Expected performance:
    // - Fast path (build-time available): < 1μs
    // - No runtime filesystem checks
    // - Immediate return
    //
    // Benchmark approach:
    // 1. Call preflight_backend_libs 1000 times
    // 2. Measure total time
    // 3. Verify average time < 1μs per call
    //
    // This test is marked #[ignore] because it requires:
    // - HAS_BITNET=true at compile time
    // - Accurate timing measurement infrastructure
    // - Isolated test environment for reliable benchmarks
    //
    // Run manually with:
    // cargo test test_preflight_fast_path_performance --ignored -- --nocapture
    todo!("AC9: Benchmark fast path performance (< 1μs when HAS_BITNET=true)");
}

/// Tests spec: runtime-detection-warning-ci-safe.md#AC2, AC3
/// Validates: Preflight backend unavailable in all detection methods
#[test]
#[serial(bitnet_env)]
fn test_preflight_backend_unavailable_everywhere() {
    // Create empty temporary directory (no libraries)
    let temp = tempfile::tempdir().expect("Failed to create temp dir");

    // Clear CI environment variables
    let _guards = [
        EnvGuard::new("CI"),
        EnvGuard::new("GITHUB_ACTIONS"),
        EnvGuard::new("JENKINS_HOME"),
        EnvGuard::new("GITLAB_CI"),
        EnvGuard::new("CIRCLECI"),
        EnvGuard::new("BITNET_TEST_NO_REPAIR"),
    ];

    for guard in &_guards {
        guard.remove();
    }

    let _guard_cpp_dir = EnvGuard::new("BITNET_CPP_DIR");
    _guard_cpp_dir.set(temp.path().to_str().unwrap());

    // TODO: Call preflight_backend_libs(CppBackend::BitNet, false) and verify:
    // 1. Build-time constant false (assumed)
    // 2. Runtime detection returns false
    // 3. Function returns Err(PreflightError::BackendUnavailable)
    //
    // Expected: Priority 3 error path when backend not found anywhere
    todo!("AC2+AC3: Verify preflight returns error when backend unavailable everywhere");
}

// ============================================================================
// Edge Cases and Error Handling
// ============================================================================

/// Tests spec: runtime-detection-warning-ci-safe.md
/// Validates: Runtime detection handles permission errors gracefully
#[test]
#[cfg(unix)]
#[ignore] // Requires special permissions setup
fn test_detect_backend_runtime_permission_error() {
    // TODO: Create directory with restricted permissions and verify:
    // 1. detect_backend_runtime returns Err(String) with permission error
    // 2. Error message is descriptive
    //
    // This test is marked #[ignore] because it requires special filesystem setup
    // with permission manipulation that may not work in all CI environments.
    todo!("Edge case: Verify runtime detection handles permission errors");
}

/// Tests spec: runtime-detection-warning-ci-safe.md#AC8
/// Validates: Empty CROSSVAL_RPATH_BITNET is handled correctly
#[test]
#[serial(bitnet_env)]
fn test_detect_backend_runtime_empty_rpath_env() {
    let _guard = EnvGuard::new("CROSSVAL_RPATH_BITNET");
    _guard.set("");

    // TODO: Call detect_backend_runtime(CppBackend::BitNet) and verify:
    // 1. Empty RPATH is ignored (not added to search candidates)
    // 2. Falls back to next priority (BITNET_CPP_DIR)
    // 3. No panic or error on empty string
    todo!("AC8: Verify empty RPATH environment variable is handled gracefully");
}

/// Tests spec: runtime-detection-warning-ci-safe.md#AC7
/// Validates: Colon-separated RPATH values are parsed correctly
#[test]
#[serial(bitnet_env)]
fn test_detect_backend_runtime_colon_separated_rpath() {
    let temp1 = tempfile::tempdir().expect("Failed to create temp1");
    let temp2 = tempfile::tempdir().expect("Failed to create temp2");

    // Create mock library in second path
    #[cfg(target_os = "linux")]
    std::fs::write(temp2.path().join("libbitnet.so"), b"mock library")
        .expect("Failed to create mock library");

    #[cfg(target_os = "macos")]
    std::fs::write(temp2.path().join("libbitnet.dylib"), b"mock library")
        .expect("Failed to create mock library");

    #[cfg(target_os = "windows")]
    std::fs::write(temp2.path().join("bitnet.dll"), b"mock library")
        .expect("Failed to create mock library");

    let rpath = format!("{}:{}", temp1.path().display(), temp2.path().display());
    let _guard = EnvGuard::new("CROSSVAL_RPATH_BITNET");
    _guard.set(&rpath);

    // TODO: Call detect_backend_runtime(CppBackend::BitNet) and verify:
    // 1. Both paths are searched
    // 2. Library found in temp2 (second path)
    // 3. Matched path equals temp2
    todo!("AC7: Verify colon-separated RPATH values are parsed and searched");
}

/// Tests spec: runtime-detection-warning-ci-safe.md
/// Validates: Symlinked library directories are followed correctly
#[test]
#[cfg(unix)]
#[ignore] // Requires symlink support
fn test_detect_backend_runtime_follows_symlinks() {
    // TODO: Create symlink to directory with libraries and verify:
    // 1. Runtime detection follows symlink
    // 2. Libraries found in symlinked target
    // 3. Matched path may be symlink or target (implementation-defined)
    //
    // This test is marked #[ignore] because symlink behavior varies by platform
    // and filesystem configuration.
    todo!("Edge case: Verify runtime detection follows symlinks correctly");
}
