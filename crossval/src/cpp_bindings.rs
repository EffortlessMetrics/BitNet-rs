//! FFI bindings to the C++ BitNet implementation
//!
//! This module provides safe Rust wrappers around the C++ BitNet implementation
//! for cross-validation purposes.

#![cfg(feature = "crossval")]

use crate::{CrossvalError, Result};
use std::ffi::{CStr, CString};
use std::os::raw::{c_char, c_int, c_void};
use std::path::Path;

// FFI declarations - these will be generated by bindgen in build.rs
extern "C" {
    fn bitnet_cpp_create_model(model_path: *const c_char) -> *mut c_void;
    fn bitnet_cpp_destroy_model(model: *mut c_void);
    fn bitnet_cpp_generate(
        model: *mut c_void,
        prompt: *const c_char,
        max_tokens: c_int,
        tokens_out: *mut u32,
        tokens_count: *mut c_int,
    ) -> c_int;
}

/// Safe wrapper around the C++ BitNet model
pub struct CppModel {
    handle: *mut c_void,
}

impl CppModel {
    /// Load a model from the given path
    pub fn load<P: AsRef<Path>>(model_path: P) -> Result<Self> {
        let path_str = model_path
            .as_ref()
            .to_str()
            .ok_or_else(|| CrossvalError::ModelLoadError("Invalid path encoding".to_string()))?;
        
        let c_path = CString::new(path_str)
            .map_err(|_| CrossvalError::ModelLoadError("Path contains null bytes".to_string()))?;
        
        let handle = unsafe { bitnet_cpp_create_model(c_path.as_ptr()) };
        
        if handle.is_null() {
            return Err(CrossvalError::ModelLoadError(format!(
                "Failed to load C++ model from: {}",
                path_str
            )));
        }
        
        Ok(CppModel { handle })
    }
    
    /// Generate tokens using the C++ implementation
    pub fn generate(&self, prompt: &str, max_tokens: usize) -> Result<Vec<u32>> {
        let c_prompt = CString::new(prompt)
            .map_err(|_| CrossvalError::InferenceError("Prompt contains null bytes".to_string()))?;
        
        let mut tokens = vec![0u32; max_tokens];
        let mut actual_count: c_int = 0;
        
        let result = unsafe {
            bitnet_cpp_generate(
                self.handle,
                c_prompt.as_ptr(),
                max_tokens as c_int,
                tokens.as_mut_ptr(),
                &mut actual_count,
            )
        };
        
        if result != 0 {
            return Err(CrossvalError::InferenceError(format!(
                "C++ generation failed with code: {}",
                result
            )));
        }
        
        if actual_count < 0 {
            return Err(CrossvalError::InferenceError(
                "Invalid token count from C++".to_string(),
            ));
        }
        
        tokens.truncate(actual_count as usize);
        Ok(tokens)
    }
}

impl Drop for CppModel {
    fn drop(&mut self) {
        if !self.handle.is_null() {
            unsafe {
                bitnet_cpp_destroy_model(self.handle);
            }
        }
    }
}

// Safety: CppModel is only used in single-threaded contexts for cross-validation
unsafe impl Send for CppModel {}

/// Check if C++ implementation is available
pub fn is_available() -> bool {
    // This will be true only when compiled with crossval feature
    // and C++ library is successfully linked
    true
}

/// Get version information from C++ implementation
pub fn version_info() -> Result<String> {
    // This would call into C++ to get version info
    // For now, return a placeholder
    Ok("BitNet.cpp (external)".to_string())
}