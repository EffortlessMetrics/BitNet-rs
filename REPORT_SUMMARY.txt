================================================================================
bitnet-rs CLI ARGUMENT PARSING PATTERNS - EXPLORATION COMPLETE
================================================================================

PROJECT: /home/steven/code/Rust/BitNet-rs
BRANCH: feat/comprehensive-integration-qk256-envguard-receipts-strict-avx2
DATE: 2025-10-25

================================================================================
DELIVERABLES CREATED
================================================================================

1. CLI_ARGUMENT_PARSING_PATTERNS.md (984 lines)
   - Comprehensive reference guide with 8 major sections
   - Real code examples from the codebase
   - Complete patterns for adding new flags
   - Validation strategies and help text conventions
   - Advanced patterns (feature gating, boxing, etc.)

2. CLI_PATTERNS_QUICK_REFERENCE.md (280 lines)
   - Quick lookup table for common patterns
   - Copy-paste ready examples
   - Checklist for adding new flags
   - Common mistakes and how to avoid them
   - Real examples from bitnet-rs codebase

================================================================================
KEY FINDINGS
================================================================================

CLAP LIBRARY USAGE:
- Project uses clap v4 with derive macros
- Patterns: #[derive(Parser)], #[derive(Args)], #[derive(Subcommand)]
- Global flags supported with global=true attribute
- Dynamic version function support (OnceLock pattern)

FILE STRUCTURE:
- Main CLI: crates/bitnet-cli/src/main.rs (1800+ lines)
- Xtask CLI: xtask/src/main.rs (6000+ lines, many subcommands)
- Commands: crates/bitnet-cli/src/commands/ (modular structure)
- Inference: crates/bitnet-inference/src/ (library with trait-based design)

================================================================================
SPECIFIC RECOMMENDATIONS FOR REQUESTED FLAGS
================================================================================

1. --cpp-backend {bitnet|llama} FLAG
   Pattern: Enum with FromStr + Display implementations
   Location: Define in bitnet-inference/src/lib.rs
   Example: See Part 3, Example 1 in full report
   
2. --prompt-template FLAG
   Status: ALREADY EXISTS in bitnet-cli
   Location: crates/bitnet-cli/src/main.rs, line 273
   Implementation: String field, parsed to TemplateType in handler
   
3. --system-prompt FLAG
   Status: ALREADY EXISTS in bitnet-cli
   Location: crates/bitnet-cli/src/main.rs, line 278
   Implementation: Optional<String> field, applied via TemplateType::apply()
   
4. --dump-ids FLAG
   Status: ALREADY EXISTS in bitnet-cli
   Location: crates/bitnet-cli/src/main.rs, line 254
   Implementation: Boolean flag with handler at line 1439
   
5. --dump-cpp-ids FLAG
   Pattern: Xtask pattern with feature gating
   Location: xtask/src/main.rs (see Part 7, Example in full report)
   Implementation: Boolean flag, feature-gated with #[cfg(feature = "inference")]

================================================================================
VALIDATION PATTERNS DISCOVERED
================================================================================

1. Environment Variable Fallback:
   #[arg(long, env = "VAR_NAME", default_value_t = false)]
   
2. Alias Support (backward compatibility):
   visible_aliases = ["alias1", "alias2"]
   
3. Conflicting Arguments (mutual exclusion):
   conflicts_with = "other_flag"
   
4. Custom Enum Validation:
   .parse::<Type>().with_context(|| format!("..."))?
   
5. Path Resolution:
   PathBuf type with Optional<PathBuf> for optional paths
   
6. Repeatable Arguments:
   Vec<T> type automatically enables --flag val1 --flag val2

================================================================================
CLAP ATTRIBUTE PATTERNS
================================================================================

Default Values:
- Strings:    default_value = "auto"
- Numbers:    default_value_t = 128
- Booleans:   default_value_t = false

Help Text:
- Single line: /// Description (as doc comment)
- Multi-line: #[command(long_about = r#"..."#)]
- Command help: #[command(about = "...")]

Metadata:
- value_name = "PATH" (shows <PATH> in help)
- short = 'v' (single-letter flag)
- long = "verbose" (full flag name)
- global = true (applies to all subcommands)

Feature Gating:
- #[cfg(feature = "name")]
- Only available when feature is enabled

================================================================================
ENUM PATTERN (MOST COMMON FOR NEW FLAGS)
================================================================================

Three-step pattern used throughout bitnet-rs:

Step 1: Define enum in library crate
   pub enum MyType { Variant1, Variant2 }

Step 2: Implement FromStr + Display
   impl std::str::FromStr for MyType { ... }
   impl std::fmt::Display for MyType { ... }

Step 3: Use as String in CLI, parse in handler
   #[arg(long, default_value = "variant1")]
   pub my_flag: String,
   
   // In handler:
   let parsed = my_flag.parse::<MyType>()?;

This allows:
- Custom error messages
- Alternative spellings (e.g., "llama3-chat" or "llama3_chat")
- Type-safe downstream handling
- Easy testing

================================================================================
HELP TEXT CONVENTIONS
================================================================================

Short Descriptions (one line):
   /// Enable verbose output

Long Descriptions (with examples):
   /// Prompt template selection
   ///
   /// # Examples
   /// - auto: Auto-detect from model
   /// - raw: No special formatting
   /// - instruct: Q&A format

Command-Level Help:
   #[command(long_about = r#"Detailed help with:
   - Multiple lines
   - Code examples
   - Usage patterns
   "#)]

Value Names (in help):
   #[arg(long, value_name = "PATH")]  // Shows --model <PATH>
   #[arg(long, value_name = "TEMPLATE")]  // Shows --template <TEMPLATE>

================================================================================
TESTING PATTERNS
================================================================================

Clap Parse Testing:
   let args = vec!["prog", "--flag", "value"];
   let cli = Cli::try_parse_from(&args).unwrap();
   assert_eq!(cli.flag, "value");

Enum Testing:
   #[test]
   fn test_enum_parsing() {
       assert!("raw".parse::<TemplateType>().is_ok());
       assert!("invalid".parse::<TemplateType>().is_err());
   }

All tests in codebase follow these patterns:
- Located in same file (after impl block)
- Use #[cfg(test)] module
- Test both success and error cases

================================================================================
STRUCTURE OVERVIEW
================================================================================

Three-level CLI structure used in bitnet-rs:

Level 1: Top-level Parser (#[derive(Parser)])
         Cli struct with global flags and subcommand dispatcher
         
Level 2: Subcommand Enum (#[derive(Subcommand)])
         Enum variants map to commands (Run, Chat, Benchmark, etc.)
         
Level 3: Command Args (#[derive(Args)])
         Reusable struct for command-specific arguments
         (e.g., InferenceCommand, BenchmarkCommand)

Advantage: Reusable command structs that can be used in multiple subcommands
          (e.g., InferenceCommand used for both "inference" and "chat")

================================================================================
ADVANCED PATTERNS IN USE
================================================================================

1. Boxing Large Structs:
   Cmd::Inference(Box<InferenceCommand>)
   Reason: InferenceCommand is ~300 bytes

2. Feature Gating:
   #[cfg(feature = "inference")]
   #[command(name = "crossval-per-token")]
   Only compiled when feature enabled

3. Dynamic Version:
   fn bitnet_version() -> &'static str { ... }
   #[command(version = bitnet_version())]
   Shows compiled features in version output

4. Marker Flags:
   #[arg(long)]
   pub qa: bool,
   Bundles multiple defaults (temp=0.7, top-p=0.95, etc.)

5. Alias Chains:
   visible_alias = "stop-sequence"
   visible_alias = "stop_sequences"
   Supports multiple spellings

================================================================================
ENVIRONMENT VARIABLE INTEGRATION
================================================================================

Clap supports environment variable fallback:
   #[arg(long, env = "VAR_NAME")]
   
Examples in bitnet-rs:
   - BITNET_ALLOW_MOCK: Fallback for --allow-mock
   - RUST_LOG: Standard log level
   - BITNET_DETERMINISTIC: Determinism flag
   - HF_TOKEN: Hugging Face authentication
   - HTTP_PROXY/HTTPS_PROXY: Automatic proxy support

Pattern: Env var is checked if flag not provided
         CLI flag takes precedence over env var

================================================================================
PRODUCTION PATTERNS OBSERVED
================================================================================

1. Error Handling:
   - Use .with_context(|| format!(...))? for actionable messages
   - Clap validates at parse time (not runtime)
   - Custom validation in handler functions

2. Help Documentation:
   - Comprehensive help text with examples
   - Value names for clarity
   - Aliases for backward compatibility

3. Configuration:
   - Config file support via #[arg(long)]
   - Merging CLI args with config file values
   - Global flags apply to all subcommands

4. Modularity:
   - Commands in separate files/modules
   - Reusable Args structs via #[derive(Args)]
   - Trait-based design in libraries

================================================================================
MOST COMMON CLAP ATTRIBUTES
================================================================================

#[arg(...)] attributes (per-field):
   - short = 'v'
   - long = "verbose"
   - default_value = "text"
   - default_value_t = 128
   - value_name = "PATH"
   - env = "VAR_NAME"
   - conflicts_with = "other"
   - visible_aliases = ["alias1", "alias2"]
   - global = true
   - value_delimiter = ','

#[command(...)] attributes (per-struct/enum):
   - name = "command"
   - about = "Short help"
   - long_about = "Long help with examples"
   - author = "Author name"
   - version = "1.0.0"
   - after_help = "Additional help"
   - alias = "short-name"
   - subcommand

================================================================================
KEY TAKEAWAYS FOR NEW CONTRIBUTORS
================================================================================

1. Use clap's derive macros, not manual parsing
   - Automatic validation
   - Consistent help formatting
   - Type safety

2. Keep flags as Strings, parse in handlers
   - Allows custom error messages
   - Supports alternative spellings
   - Easier to test

3. Use FromStr + Display for custom enums
   - Standard Rust pattern
   - Works everywhere strings are parsed
   - Self-documenting via Display impl

4. Document with doc comments
   - Auto-generates help text
   - Shows in IDE tooltips
   - Enforced by linters

5. Test all flag combinations
   - Use try_parse_from for unit tests
   - Test both success and error cases
   - Clap validates, but your handler may not

6. Use value_name consistently
   - Improves help text readability
   - Shows what type of value is expected
   - Examples: "PATH", "TEMPLATE", "N", "SEED"

7. Provide aliases for backward compatibility
   - visible_aliases for flags
   - #[command(alias = "...")] for subcommands
   - Makes migration easier for users

================================================================================
FILES GENERATED
================================================================================

1. CLI_ARGUMENT_PARSING_PATTERNS.md
   Location: /home/steven/code/Rust/BitNet-rs/
   Size: 984 lines
   Content: Complete reference with 8 sections, code examples, patterns

2. CLI_PATTERNS_QUICK_REFERENCE.md
   Location: /home/steven/code/Rust/BitNet-rs/
   Size: 280 lines
   Content: Quick lookup, checklists, common mistakes, real examples

3. REPORT_SUMMARY.txt (this file)
   Location: /home/steven/code/Rust/BitNet-rs/
   Content: Executive summary of findings

================================================================================
HOW TO USE THESE DOCUMENTS
================================================================================

For a quick start:
   1. Read CLI_PATTERNS_QUICK_REFERENCE.md (10-15 minutes)
   2. Copy pattern that matches your needs
   3. Use checklist to verify implementation

For detailed understanding:
   1. Read CLI_ARGUMENT_PARSING_PATTERNS.md Part 1 (15 minutes)
   2. Find your specific pattern in Part 3 (5 minutes)
   3. Copy implementation from example (5 minutes)
   4. Refer to Part 4-8 for advanced patterns as needed

For reference while coding:
   - Keep QUICK_REFERENCE.md open in IDE
   - Use file locations table to jump to examples
   - Copy-paste entire sections from FULL report

================================================================================
VALIDATION CHECKLIST FOR NEW FLAGS
================================================================================

Design Phase:
  [ ] Flag name is clear and unambiguous
  [ ] Default value makes sense for most users
  [ ] Aliases support common variations
  [ ] Help text explains purpose and values
  
Implementation Phase:
  [ ] Added to correct struct (Parser/Args/Subcommand)
  [ ] #[arg(...)] attributes include defaults
  [ ] Doc comment provided (/// Description)
  [ ] value_name included for clarity
  
Integration Phase:
  [ ] Flag handled in command dispatcher
  [ ] Validation logic added (if enum)
  [ ] Error messages use .with_context()
  [ ] Default values tested
  
Documentation Phase:
  [ ] Help text includes examples
  [ ] Aliases documented
  [ ] Conflicts documented (if applicable)
  [ ] Environment variable fallback noted (if applicable)

================================================================================
NEXT STEPS FOR IMPLEMENTING NEW FLAGS
================================================================================

Option 1: Simple Flag (Boolean or String)
  Time: 5-10 minutes
  Complexity: Low
  Example: --dump-ids, --verbose, --format json
  
Option 2: Numeric or Path Flag
  Time: 10-15 minutes
  Complexity: Low
  Example: --max-tokens 128, --model path/to/model.gguf
  
Option 3: Enum-Based Flag
  Time: 20-30 minutes
  Complexity: Medium
  Example: --cpp-backend bitnet|llama, --template raw|instruct|llama3-chat
  Requires: FromStr + Display impl + tests
  
Option 4: Complex Flag with Validation
  Time: 30-45 minutes
  Complexity: High
  Example: Conflicting flags, conditional validation
  Requires: Custom validation logic + error handling

Start with QUICK_REFERENCE.md Pattern section that matches your use case!

================================================================================
QUESTIONS ANSWERED
================================================================================

1. How to add --cpp-backend flag?
   See: Part 3, Example 1 of full report (complete 4-step pattern)

2. How does --prompt-template work?
   See: Part 3, Example 2 of full report (already implemented, detailed)

3. Where to add new flags?
   See: Table of file locations in quick reference (2-3 files needed)

4. How to validate enum flags?
   See: Part 4, Pattern 3 of full report + Part 2 example

5. How to add help text?
   See: Part 5 of full report (5 different patterns)

6. How to test new flags?
   See: Part 8 in full report + testing patterns section

7. What's the project's convention for flag naming?
   See: Part 5 "Help Text Patterns" - uses --kebab-case

8. How to add backwards compatible aliases?
   See: Part 4, Pattern 4 of full report (visible_aliases)

================================================================================
END OF REPORT
================================================================================

Generated: 2025-10-25
Explored Codebase: /home/steven/code/Rust/BitNet-rs
Branch: feat/comprehensive-integration-qk256-envguard-receipts-strict-avx2

For questions or clarifications, refer to the full report or the actual
implementation files referenced in the "File Locations" section.

