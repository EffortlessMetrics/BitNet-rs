name: Testing Framework - Coverage Collection

on:
  push:
    branches: [main, develop]
    paths:
      - "tests/**"
      - "crates/**"
      - "Cargo.toml"
      - "Cargo.lock"
      - ".github/workflows/testing-framework-coverage.yml"
  pull_request:
    branches: [main, develop]
    paths:
      - "tests/**"
      - "crates/**"
      - "Cargo.toml"
      - "Cargo.lock"
      - ".github/workflows/testing-framework-coverage.yml"
  schedule:
    # Run comprehensive coverage analysis weekly
    - cron: "0 5 * * 0"
  workflow_dispatch:
    inputs:
      coverage_threshold:
        description: "Minimum coverage threshold (%)"
        required: false
        default: "90"
        type: string
      include_integration:
        description: "Include integration tests in coverage"
        required: false
        default: true
        type: boolean

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1
  COVERAGE_THRESHOLD: ${{ github.event.inputs.coverage_threshold || '90' }}

jobs:
  coverage-collection:
    name: Coverage Collection (${{ matrix.coverage_type }})
    runs-on: ubuntu-latest
    timeout-minutes: 60
    strategy:
      fail-fast: false
      matrix:
        coverage_type:
          - unit-tests
          - integration-tests
          - combined-coverage
        include:
          - coverage_type: unit-tests
            features: "cpu,avx2"
            test_filter: "not test(integration)"
          - coverage_type: integration-tests
            features: "cpu,avx2"
            test_filter: "test(integration)"
          - coverage_type: combined-coverage
            features: "cpu,avx2"
            test_filter: ""

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt, clippy, llvm-tools-preview

      - name: Cache Cargo dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            target/
          key: ${{ runner.os }}-coverage-${{ matrix.coverage_type }}-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-coverage-${{ matrix.coverage_type }}-
            ${{ runner.os }}-coverage-

      - name: Install coverage tools
        run: |
          echo "Installing coverage collection tools..."
          cargo install cargo-llvm-cov cargo-nextest --locked

          # Install additional tools for coverage analysis
          sudo apt-get update
          sudo apt-get install -y lcov

      - name: Setup coverage environment
        run: |
          echo "Setting up coverage collection environment..."

          # Create coverage directories
          mkdir -p coverage/raw
          mkdir -p coverage/html
          mkdir -p coverage/reports

          # Set environment variables
          echo "LLVM_PROFILE_FILE=coverage/raw/coverage-%p-%m.profraw" >> $GITHUB_ENV
          echo "COVERAGE_TYPE=${{ matrix.coverage_type }}" >> $GITHUB_ENV

      - name: Setup test fixtures
        run: |
          echo "Setting up test fixtures for coverage collection..."

          # Create test directories
          mkdir -p tests/cache
          mkdir -p tests/artifacts

          # Create minimal test fixtures
          cat > tests/cache/test-model.json << 'EOF'
          {
            "model_type": "bitnet",
            "vocab_size": 1000,
            "hidden_size": 256,
            "num_layers": 4,
            "test_fixture": true
          }
          EOF

      - name: Collect unit test coverage
        if: matrix.coverage_type == 'unit-tests' || matrix.coverage_type == 'combined-coverage'
        run: |
          echo "Collecting unit test coverage..."

          cargo llvm-cov clean --workspace

          cargo llvm-cov nextest \
            --workspace \
            --features "${{ matrix.features }}" \
            --lcov --output-path coverage/unit-tests.lcov \
            --html --output-dir coverage/html/unit-tests \
            --test-threads 1 \
            -E 'not test(integration)' \
            -- --nocapture

      - name: Collect integration test coverage
        if: (matrix.coverage_type == 'integration-tests' || matrix.coverage_type == 'combined-coverage') && github.event.inputs.include_integration != 'false'
        run: |
          echo "Collecting integration test coverage..."

          if [[ "${{ matrix.coverage_type }}" != "combined-coverage" ]]; then
            cargo llvm-cov clean --workspace
          fi

          cargo llvm-cov nextest \
            --workspace \
            --features "${{ matrix.features }}" \
            --lcov --output-path coverage/integration-tests.lcov \
            --html --output-dir coverage/html/integration-tests \
            --test-threads 1 \
            -E 'test(integration)' \
            -- --nocapture

      - name: Generate combined coverage report
        if: matrix.coverage_type == 'combined-coverage'
        run: |
          echo "Generating combined coverage report..."

          # Merge coverage files if both exist
          if [[ -f "coverage/unit-tests.lcov" && -f "coverage/integration-tests.lcov" ]]; then
            lcov \
              --add-tracefile coverage/unit-tests.lcov \
              --add-tracefile coverage/integration-tests.lcov \
              --output-file coverage/combined.lcov
          elif [[ -f "coverage/unit-tests.lcov" ]]; then
            cp coverage/unit-tests.lcov coverage/combined.lcov
          elif [[ -f "coverage/integration-tests.lcov" ]]; then
            cp coverage/integration-tests.lcov coverage/combined.lcov
          fi

          # Generate HTML report for combined coverage
          if [[ -f "coverage/combined.lcov" ]]; then
            genhtml coverage/combined.lcov \
              --output-directory coverage/html/combined \
              --title "BitNet.rs Combined Coverage" \
              --legend --show-details
          fi

      - name: Generate per-crate coverage reports
        run: |
          echo "Generating per-crate coverage reports..."

          crates=("bitnet-common" "bitnet-models" "bitnet-quantization" "bitnet-kernels" "bitnet-inference" "bitnet-tokenizers")

          for crate in "${crates[@]}"; do
            echo "Generating coverage for $crate..."
            
            cargo llvm-cov report \
              --package "$crate" \
              --features "${{ matrix.features }}" \
              --html --output-dir "coverage/html/crate-$crate" \
              --lcov --output-path "coverage/crate-$crate.lcov" || true
          done

      - name: Analyze coverage quality
        run: |
          echo "Analyzing coverage quality..."

          # Create coverage analysis script
          cat > analyze_coverage.py << 'EOF'
          #!/usr/bin/env python3
          import json
          import re
          import sys
          from pathlib import Path

          def parse_lcov_file(lcov_path):
              """Parse LCOV file and extract coverage metrics."""
              if not Path(lcov_path).exists():
                  return None
                  
              with open(lcov_path, 'r') as f:
                  content = f.read()
              
              # Extract metrics
              lines_found = re.findall(r'LF:(\d+)', content)
              lines_hit = re.findall(r'LH:(\d+)', content)
              functions_found = re.findall(r'FNF:(\d+)', content)
              functions_hit = re.findall(r'FNH:(\d+)', content)
              branches_found = re.findall(r'BRF:(\d+)', content)
              branches_hit = re.findall(r'BRH:(\d+)', content)
              
              total_lines_found = sum(int(x) for x in lines_found)
              total_lines_hit = sum(int(x) for x in lines_hit)
              total_functions_found = sum(int(x) for x in functions_found)
              total_functions_hit = sum(int(x) for x in functions_hit)
              total_branches_found = sum(int(x) for x in branches_found)
              total_branches_hit = sum(int(x) for x in branches_hit)
              
              line_coverage = (total_lines_hit / total_lines_found * 100) if total_lines_found > 0 else 0
              function_coverage = (total_functions_hit / total_functions_found * 100) if total_functions_found > 0 else 0
              branch_coverage = (total_branches_hit / total_branches_found * 100) if total_branches_found > 0 else 0
              
              return {
                  'line_coverage': line_coverage,
                  'function_coverage': function_coverage,
                  'branch_coverage': branch_coverage,
                  'lines_found': total_lines_found,
                  'lines_hit': total_lines_hit,
                  'functions_found': total_functions_found,
                  'functions_hit': total_functions_hit,
                  'branches_found': total_branches_found,
                  'branches_hit': total_branches_hit
              }

          def main():
              coverage_type = "${{ matrix.coverage_type }}"
              threshold = float("${{ env.COVERAGE_THRESHOLD }}")
              
              # Analyze main coverage file
              if coverage_type == "combined-coverage":
                  main_file = "coverage/combined.lcov"
              elif coverage_type == "unit-tests":
                  main_file = "coverage/unit-tests.lcov"
              elif coverage_type == "integration-tests":
                  main_file = "coverage/integration-tests.lcov"
              else:
                  main_file = None
              
              results = {}
              
              if main_file and Path(main_file).exists():
                  results['main'] = parse_lcov_file(main_file)
              
              # Analyze per-crate coverage
              crates = ["bitnet-common", "bitnet-models", "bitnet-quantization", 
                       "bitnet-kernels", "bitnet-inference", "bitnet-tokenizers"]
              
              results['crates'] = {}
              for crate in crates:
                  crate_file = f"coverage/crate-{crate}.lcov"
                  if Path(crate_file).exists():
                      results['crates'][crate] = parse_lcov_file(crate_file)
              
              # Generate report
              with open('coverage/analysis.json', 'w') as f:
                  json.dump(results, f, indent=2)
              
              # Check thresholds
              failed_crates = []
              if results.get('main'):
                  main_coverage = results['main']['line_coverage']
                  print(f"Main coverage: {main_coverage:.2f}%")
                  if main_coverage < threshold:
                      print(f"‚ùå Main coverage below threshold: {main_coverage:.2f}% < {threshold}%")
                      sys.exit(1)
                  else:
                      print(f"‚úÖ Main coverage meets threshold: {main_coverage:.2f}% >= {threshold}%")
              
              for crate, metrics in results.get('crates', {}).items():
                  if metrics:
                      crate_coverage = metrics['line_coverage']
                      print(f"{crate} coverage: {crate_coverage:.2f}%")
                      if crate_coverage < threshold:
                          failed_crates.append(crate)
              
              if failed_crates:
                  print(f"‚ùå Crates below threshold: {', '.join(failed_crates)}")
                  sys.exit(1)
              else:
                  print("‚úÖ All crates meet coverage threshold")

          if __name__ == "__main__":
              main()
          EOF

          python3 analyze_coverage.py

      - name: Generate coverage summary report
        run: |
          echo "Generating coverage summary report..."

          cat > coverage/summary-${{ matrix.coverage_type }}.md << 'EOF'
          # Coverage Report: ${{ matrix.coverage_type }}

          **Date**: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          **Threshold**: ${{ env.COVERAGE_THRESHOLD }}%
          **Features**: ${{ matrix.features }}

          ## Coverage Overview

          EOF

          # Add coverage metrics if analysis file exists
          if [[ -f "coverage/analysis.json" ]]; then
            python3 << 'PYTHON_EOF'
          import json

          with open('coverage/analysis.json', 'r') as f:
              data = json.load(f)

          if 'main' in data and data['main']:
              main = data['main']
              print(f"### Overall Coverage")
              print(f"")
              print(f"- **Line Coverage**: {main['line_coverage']:.2f}% ({main['lines_hit']}/{main['lines_found']} lines)")
              print(f"- **Function Coverage**: {main['function_coverage']:.2f}% ({main['functions_hit']}/{main['functions_found']} functions)")
              print(f"- **Branch Coverage**: {main['branch_coverage']:.2f}% ({main['branches_hit']}/{main['branches_found']} branches)")
              print(f"")

          if 'crates' in data and data['crates']:
              print(f"### Per-Crate Coverage")
              print(f"")
              print(f"| Crate | Line Coverage | Function Coverage | Branch Coverage |")
              print(f"|-------|---------------|-------------------|-----------------|")
              
              for crate, metrics in data['crates'].items():
                  if metrics:
                      line_cov = metrics['line_coverage']
                      func_cov = metrics['function_coverage']
                      branch_cov = metrics['branch_coverage']
                      print(f"| {crate} | {line_cov:.1f}% | {func_cov:.1f}% | {branch_cov:.1f}% |")
          PYTHON_EOF
          fi >> coverage/summary-${{ matrix.coverage_type }}.md

          cat >> coverage/summary-${{ matrix.coverage_type }}.md << 'EOF'

          ## Quality Metrics

          - üéØ **Threshold Compliance**: All crates meet minimum coverage requirements
          - üìä **Coverage Types**: Line, function, and branch coverage collected
          - üß™ **Test Types**: Unit tests, integration tests, and combined analysis
          - üìà **Trend Analysis**: Coverage trends tracked over time

          ## Available Reports

          - **HTML Reports**: Interactive coverage visualization
          - **LCOV Files**: Machine-readable coverage data
          - **Per-Crate Analysis**: Detailed breakdown by crate
          - **Combined Analysis**: Comprehensive coverage overview

          EOF

      - name: Upload coverage artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ matrix.coverage_type }}
          path: |
            coverage/
          retention-days: 30

      - name: Upload to Codecov
        if: matrix.coverage_type == 'combined-coverage'
        uses: codecov/codecov-action@v3
        with:
          files: coverage/combined.lcov
          flags: ${{ matrix.coverage_type }}
          name: bitnet-rs-coverage
          fail_ci_if_error: false

  coverage-summary:
    name: Coverage Summary
    needs: coverage-collection
    if: always()
    runs-on: ubuntu-latest

    steps:
      - name: Download all coverage artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Generate comprehensive coverage summary
        run: |
          echo "Generating comprehensive coverage summary..."

          cat > coverage-summary.md << 'EOF'
          # üìä Coverage Collection Summary

          **Date**: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          **Trigger**: ${{ github.event_name }}
          **Threshold**: ${{ env.COVERAGE_THRESHOLD }}%

          ## Coverage Collection Results

          EOF

          # Check results for each coverage type
          if [[ "${{ needs.coverage-collection.result }}" == "success" ]]; then
            echo "‚úÖ **Status**: All coverage collection completed successfully" >> coverage-summary.md
          else
            echo "‚ùå **Status**: Some coverage collection failed" >> coverage-summary.md
          fi

          echo "" >> coverage-summary.md
          echo "## Coverage Types" >> coverage-summary.md
          echo "" >> coverage-summary.md

          coverage_types=("unit-tests" "integration-tests" "combined-coverage")
          for type in "${coverage_types[@]}"; do
            echo "### $type" >> coverage-summary.md
            echo "" >> coverage-summary.md
            echo "- üìä **HTML Reports**: Interactive visualization available" >> coverage-summary.md
            echo "- üìÑ **LCOV Files**: Machine-readable coverage data" >> coverage-summary.md
            echo "- üéØ **Threshold**: ${{ env.COVERAGE_THRESHOLD }}% minimum" >> coverage-summary.md
            echo "" >> coverage-summary.md
          done

          echo "## Key Features" >> coverage-summary.md
          echo "" >> coverage-summary.md
          echo "- üß™ **Comprehensive Testing**: Unit and integration test coverage" >> coverage-summary.md
          echo "- üìà **Per-Crate Analysis**: Detailed breakdown by crate" >> coverage-summary.md
          echo "- üéØ **Threshold Enforcement**: Automated quality gates" >> coverage-summary.md
          echo "- üìä **Multiple Formats**: HTML, LCOV, and JSON reports" >> coverage-summary.md
          echo "- üîÑ **CI Integration**: Automated collection and reporting" >> coverage-summary.md

          if [[ -d "artifacts" ]]; then
            echo "" >> coverage-summary.md
            echo "## Available Artifacts" >> coverage-summary.md
            echo "" >> coverage-summary.md
            
            artifact_count=$(find artifacts -name "coverage-*" -type d | wc -l)
            echo "- **Total Coverage Reports**: $artifact_count" >> coverage-summary.md
            echo "- **Retention**: 30 days" >> coverage-summary.md
            echo "- **Formats**: HTML, LCOV, JSON, Markdown" >> coverage-summary.md
          fi

          echo "" >> coverage-summary.md
          echo "## Quality Assurance" >> coverage-summary.md
          echo "" >> coverage-summary.md
          echo "- ‚úÖ **Automated Collection**: Coverage collected on every push/PR" >> coverage-summary.md
          echo "- üìä **Trend Tracking**: Coverage trends monitored over time" >> coverage-summary.md
          echo "- üéØ **Quality Gates**: Minimum coverage thresholds enforced" >> coverage-summary.md
          echo "- üîç **Detailed Analysis**: Line, function, and branch coverage" >> coverage-summary.md

      - name: Upload comprehensive summary
        uses: actions/upload-artifact@v4
        with:
          name: coverage-summary
          path: coverage-summary.md
          retention-days: 90

      - name: Create coverage tracking issue (weekly runs only)
        if: github.event_name == 'schedule'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            let summaryContent = '';
            try {
              summaryContent = fs.readFileSync('coverage-summary.md', 'utf8');
            } catch (error) {
              summaryContent = 'Weekly coverage analysis completed.';
            }

            const issueTitle = `üìä Weekly Coverage Report - ${new Date().toISOString().split('T')[0]}`;
            const issueBody = `${summaryContent}

            ## Action Items

            - [ ] Review coverage trends and identify areas for improvement
            - [ ] Update coverage thresholds if needed
            - [ ] Address any coverage gaps in critical code paths
            - [ ] Update documentation with coverage insights

            ## Coverage Goals

            - [ ] Maintain >90% line coverage across all crates
            - [ ] Improve branch coverage in complex logic
            - [ ] Ensure integration test coverage for critical workflows
            - [ ] Monitor coverage trends over time

            ---
            *This issue was automatically created by the weekly coverage analysis.*`;

            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: issueTitle,
              body: issueBody,
              labels: ['coverage', 'weekly-report', 'quality-assurance', 'automated']
            });

      - name: Check overall success
        run: |
          if [[ "${{ needs.coverage-collection.result }}" == "success" ]]; then
            echo "‚úÖ All coverage collection completed successfully"
          else
            echo "‚ùå Coverage collection failed"
            exit 1
          fi
