# BitNet.cpp Integration - Documentation Index

This directory contains comprehensive documentation on how BitNet-rs integrates with Microsoft's BitNet C++ implementation via FFI (Foreign Function Interface).

## Quick Start

If you're new to the integration, start here:
- **[BITNET_CPP_QUICK_REFERENCE.md](BITNET_CPP_QUICK_REFERENCE.md)** - 5-minute overview with common tasks and APIs

## Comprehensive Reference

For complete technical details:
- **[BITNET_CPP_INTEGRATION_ANALYSIS.md](BITNET_CPP_INTEGRATION_ANALYSIS.md)** - Full technical reference (8 sections)

## Key Topics

### 1. Environment Variable Setup
**File:** BITNET_CPP_INTEGRATION_ANALYSIS.md ¬ß 1

How to set `BITNET_CPP_DIR` and related environment variables:
```bash
export BITNET_CPP_DIR=$HOME/.cache/bitnet_cpp
cargo run -p xtask -- fetch-cpp
```

### 2. FFI Architecture
**File:** BITNET_CPP_INTEGRATION_ANALYSIS.md ¬ß 2

Understand the three-tier wrapper design:
- Raw FFI bindings (auto-generated by bindgen)
- Safe Rust wrappers (Model, Context, Session structs)
- High-level API (public re-exports)

### 3. Cross-Validation Infrastructure
**File:** BITNET_CPP_INTEGRATION_ANALYSIS.md ¬ß 3 & BITNET_CPP_QUICK_REFERENCE.md

How to run parity tests comparing Rust vs C++ implementations:
```bash
export CROSSVAL_GGUF=/path/to/model.gguf
cargo test -p crossval --features crossval,integration-tests parity_bitnetcpp
```

### 4. Build Integration
**File:** BITNET_CPP_INTEGRATION_ANALYSIS.md ¬ß 4

Details on how build scripts link C++ libraries and generate bindings:
- `bitnet-sys/build.rs` - Primary FFI setup
- `crossval/build.rs` - Optional C++ discovery
- Feature flags and conditional compilation

### 5. API Reference
**File:** BITNET_CPP_INTEGRATION_ANALYSIS.md ¬ß 6 & BITNET_CPP_QUICK_REFERENCE.md

Complete list of available APIs:
- Model loading and context creation
- Tokenization
- Evaluation and logits extraction
- Token generation
- Utilities

### 6. Tokenizer Parity
**File:** BITNET_CPP_INTEGRATION_ANALYSIS.md ¬ß 5

Tokenization testing and known issues:
- Current status and validation approach
- Issue #469 blocking improvements
- Existing comparison infrastructure

### 7. Intermediate Activation Extraction
**File:** BITNET_CPP_INTEGRATION_ANALYSIS.md ¬ß 7

Current limitations and workarounds:
- Why intermediate layer activations aren't available (llama.cpp limitation)
- Option 1: Per-position logits analysis (feasible now)
- Option 2: C shim extension (requires C++ modification)
- Option 3: Separate debug tool (less intrusive)

### 8. Session Management
**File:** BITNET_CPP_INTEGRATION_ANALYSIS.md ¬ß 8

Thread-safe session reuse for testing:
- Global reusable FFI session pattern
- Memory management and crash prevention
- Deterministic execution setup

## File Locations

### Source Code

**FFI Bindings:**
- `crates/bitnet-sys/include/bitnet_c.h` - C API contract
- `crates/bitnet-sys/csrc/bitnet_c_shim.cc` - C++ shim implementation
- `crates/bitnet-sys/src/wrapper.rs` - Safe Rust wrappers
- `crates/bitnet-sys/build.rs` - Build script

**Cross-Validation:**
- `crossval/` - Test framework crate
- `crossval/tests/parity_bitnetcpp.rs` - Main parity tests
- `crossval/tests/parity.rs` - Comparison harness
- `crates/bitnet-inference/src/ffi_session.rs` - Session management

### Documentation

- `docs/BITNET_CPP_QUICK_REFERENCE.md` - Quick lookup (this directory)
- `docs/BITNET_CPP_INTEGRATION_ANALYSIS.md` - Complete reference (this directory)
- `docs/BITNET_CPP_INTEGRATION_INDEX.md` - This file
- `docs/CROSSVAL.md` - Cross-validation setup guide
- `docs/CROSSVAL_TESTING.md` - Testing framework documentation

## Common Tasks

### Run Parity Tests

```bash
export CROSSVAL_GGUF=/path/to/model.gguf
cargo test -p crossval --features crossval,integration-tests parity_bitnetcpp
```

See: BITNET_CPP_QUICK_REFERENCE.md ¬ß Cross-Validation Testing

### Load a Model and Run Inference

```rust
use bitnet_sys::wrapper::Session;

let session = Session::load_deterministic("path/to/model.gguf")?;
let tokens = session.tokenize("Hello world")?;
let logits = session.eval_and_get_logits(&tokens, 0)?;
```

See: BITNET_CPP_QUICK_REFERENCE.md ¬ß Core APIs

### Build with FFI Support

```bash
cargo build --features ffi
cargo test --features ffi -p bitnet-sys
```

See: BITNET_CPP_INTEGRATION_ANALYSIS.md ¬ß 4

### Extract Per-Position Logits

```rust
// Setup context with logits_all=true (automatic in wrapper)
context.eval(tokens, 0)?;

// Get logits for specific position
let logits_at_pos_0 = context.get_logits_ith(0)?;
let logits_at_pos_1 = context.get_logits_ith(1)?;
```

See: BITNET_CPP_QUICK_REFERENCE.md ¬ß Logits Extraction

## Architecture Diagram

```
bitnet.cpp (Microsoft C++ Reference)
    ‚Üì
llama.cpp (Backend)
    ‚Üì
bitnet_c_shim.cc (C Wrapper - bridges C++ to C)
    ‚Üì
bindings.rs (Raw FFI - auto-generated by bindgen)
    ‚Üì
wrapper.rs (Safe Wrappers - Model, Context, Session)
    ‚Üì
Public API (bitnet-sys/lib.rs exports)
    ‚Üì
Cross-Validation Tests (crossval crate)
    ‚Üì
parity_bitnetcpp.rs (Rust vs C++ comparison)
```

## What Can We Compare?

### ‚úÖ Fully Supported

- Logits from final layer
- Token sequences from greedy generation
- Tokenization outputs
- Vocabulary size and model properties
- Per-position logits (with llama_get_logits_ith)

### ‚ùå Not Available (llama.cpp Limitation)

- Intermediate layer activations
- Attention weights/maps
- Hidden state dimensions
- Gradient flows

### üîß Could Be Added (Requires Work)

- Layer-by-layer activation comparison
- Attention map comparison
- Full model instrumentation

See: BITNET_CPP_INTEGRATION_ANALYSIS.md ¬ß 7

## Troubleshooting

### FFI Not Available

**Problem:** "BITNET_CPP_DIR not set" or "Failed to load C++ model"

**Solution:**
```bash
cargo run -p xtask -- fetch-cpp
export BITNET_CPP_DIR=$HOME/.cache/bitnet_cpp
```

See: BITNET_CPP_QUICK_REFERENCE.md ¬ß Troubleshooting

### Parity Test Failures

**Problem:** Logits differ beyond tolerance (1e-4)

**Checklist:**
1. ‚úì Same model file used on both sides
2. ‚úì Deterministic settings: `OMP_NUM_THREADS=1`, `GGML_NUM_THREADS=1`
3. ‚úì Same tokenization settings
4. ‚úì Greedy sampling (no randomness)

See: BITNET_CPP_INTEGRATION_ANALYSIS.md ¬ß 3

### Build Errors

**Problem:** "clang not found" or library linking errors

**Solution:**
- Ubuntu/Debian: `sudo apt install clang libclang-dev`
- macOS: `xcode-select --install`
- Verify C++ implementation: `ls $BITNET_CPP_DIR/build`

See: BITNET_CPP_INTEGRATION_ANALYSIS.md ¬ß 4

## Related Documentation

- `docs/CROSSVAL.md` - Full cross-validation setup and testing guide
- `docs/development/test-suite.md` - General testing infrastructure
- `docs/environment-variables.md` - All environment variables used in project
- `CLAUDE.md` ¬ß Cross-Validation - Project-level cross-validation guidance

## Key Insights

### Why Three Tiers of Wrappers?

1. **Raw FFI (bindings.rs):** Auto-generated, low-level, dangerous but complete
2. **Safe Wrappers (wrapper.rs):** Manual, ergonomic, memory-safe, Rust idioms
3. **Public API:** Selective exports, clear contracts, production-ready

This layering allows:
- Easy regeneration of bindings (just re-run bindgen)
- Gradual abstraction (add safety as needed)
- Clear responsibility boundaries
- Testability at each level

### Why Global Session Pattern?

The `PARITY_CPP_SESSION` global pattern prevents:
- Repeated model/context allocation (caused munmap_chunk() crashes)
- Memory leaks from incomplete cleanup
- Context-switching overhead in tests

Alternative approaches were tried (stack allocation, thread-local) but caused subtle memory corruption at the FFI boundary.

### Why Per-Position Logits Matter

Standard evaluation returns logits for the last token. Per-position logits allow:
- Detection of exactly where Rust/C++ diverge
- Verification of attention/KV cache correctness
- Fine-grained debugging of quantization differences
- Foundation for future layer-by-layer comparison

## Future Work

### Short Term (1-2 months)
- [ ] Add per-position logits wrapper functions
- [ ] Create position-wise divergence test
- [ ] Document logits interpretation guide

### Medium Term (3-6 months)
- [ ] Evaluate need for intermediate activations
- [ ] Prototype llama.cpp instrumentation
- [ ] Design debug format (JSON/protobuf)

### Long Term
- [ ] Consider full layer-by-layer harness
- [ ] Integrate with model quality metrics
- [ ] Support batch comparison scenarios

## Contributing

When modifying FFI integration:

1. **Modify C API** ‚Üí Update `bitnet_c.h`
2. **Modify C++ Shim** ‚Üí Update `bitnet_c_shim.cc`
3. **Rebuild bindings** ‚Üí Run `cargo build --features ffi` (automatic)
4. **Add Rust wrapper** ‚Üí Update `wrapper.rs` with safe abstractions
5. **Test thoroughly** ‚Üí Add tests in `crossval/tests/`
6. **Update docs** ‚Üí Revise this documentation

## Questions?

For detailed information on any topic:
- Check BITNET_CPP_QUICK_REFERENCE.md for quick answers
- Check BITNET_CPP_INTEGRATION_ANALYSIS.md for complete details
- Check relevant source files (linked in each section)
- Check related documentation files listed above

For architecture discussions or design decisions:
- Review comments in `wrapper.rs` and `bitnet_c_shim.cc`
- Check commit history for rationale
- See archived decision documents in `archive/`

---

Last Updated: October 24, 2025
Documentation Version: 1.0
