//! Tests verifying receipt schema invariants.
//!
//! Focused on the four core guarantees:
//! 1. Schema version constant == "1.0.0"
//! 2. `compute_path` is "real" (distinct from "mock")
//! 3. Kernel ID hygiene: non-empty, length ≤ 128
//! 4. Selected backend is recorded in the receipt

use bitnet_receipts::{InferenceReceipt, RECEIPT_SCHEMA_VERSION};
use proptest::prelude::*;

// ── Unit tests ────────────────────────────────────────────────────────────────

#[test]
fn schema_version_constant_is_correct() {
    assert_eq!(RECEIPT_SCHEMA_VERSION, "1.0.0");
}

#[test]
fn compute_path_real_and_mock_are_distinct() {
    let real = "real";
    let mock = "mock";
    assert_ne!(real, mock);
    assert_eq!(real, "real");
}

/// `generate()` records the backend passed to it in the receipt's `backend` field.
#[test]
fn selected_backend_is_recorded_in_receipt() {
    let receipt = InferenceReceipt::generate("cpu", vec!["i2s_gemv".to_string()], None).unwrap();
    assert_eq!(receipt.backend, "cpu");
}

// ── Property tests ────────────────────────────────────────────────────────────

proptest! {
    /// Every kernel ID generated by the valid-ID regex is non-empty and within
    /// the 128-character limit.  This encodes the hygiene contract as a spec test.
    #[test]
    fn kernel_id_must_not_be_empty(
        kernel_ids in prop::collection::vec(
            prop::string::string_regex("[a-z_]{1,128}").unwrap(),
            0..10,
        )
    ) {
        for id in &kernel_ids {
            prop_assert!(!id.is_empty(), "kernel_id must not be empty");
            prop_assert!(id.len() <= 128, "kernel_id must be ≤ 128 chars, got {}", id.len());
        }
    }

    /// Any single valid kernel ID string is non-empty and within the 128-character limit.
    #[test]
    fn kernel_id_length_within_bounds(
        s in prop::string::string_regex("[a-z_]{1,128}").unwrap()
    ) {
        prop_assert!(!s.is_empty());
        prop_assert!(s.len() <= 128);
    }

    /// `validate_kernel_ids()` accepts receipts whose kernel IDs are all valid
    /// (non-empty, ≤ 128 chars, no mock prefix).
    #[test]
    fn valid_kernel_ids_accepted_by_validate(
        kernels in prop::collection::vec(
            prop::string::string_regex("[a-z][a-z0-9_]{0,30}").unwrap(),
            1..8,
        )
    ) {
        let kernels: Vec<String> = kernels
            .into_iter()
            .filter(|k| !k.is_empty() && k.len() <= 128 && !k.to_lowercase().contains("mock"))
            .collect();
        if kernels.is_empty() {
            return Ok(());
        }
        let receipt = InferenceReceipt::generate("cpu", kernels, None).unwrap();
        prop_assert!(receipt.validate_kernel_ids().is_ok());
    }

    /// A kernel ID whose length exceeds 128 characters causes `validate_kernel_ids()`
    /// to return an error.
    #[test]
    fn oversized_kernel_id_rejected_by_validate(extra in 1_usize..50) {
        let oversized = "k".repeat(128 + extra);
        let mut receipt =
            InferenceReceipt::generate("cpu", vec!["i2s_gemv".to_string()], None).unwrap();
        receipt.kernels = vec![oversized];
        prop_assert!(receipt.validate_kernel_ids().is_err());
    }
}
